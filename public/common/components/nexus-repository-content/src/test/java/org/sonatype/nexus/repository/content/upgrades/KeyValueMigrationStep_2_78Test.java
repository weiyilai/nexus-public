/*
 * Sonatype Nexus (TM) Open Source Version
 * Copyright (c) 2008-present Sonatype, Inc.
 * All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.
 *
 * This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
 * which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.
 *
 * Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
 * of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
 * Eclipse Foundation. All other trademarks are the property of their respective owners.
 */
package org.sonatype.nexus.repository.content.upgrades;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.List;

import org.sonatype.goodies.testsupport.Test5Support;
import org.sonatype.nexus.testdb.DataSessionConfiguration;
import org.sonatype.nexus.testdb.DatabaseExtension;
import org.sonatype.nexus.testdb.TestDataSessionSupplier;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertTrue;

@ExtendWith(DatabaseExtension.class)
class KeyValueMigrationStep_2_78Test
    extends Test5Support
{
  private static final List<String> FORMATS = List.of("apt", "helm", "yum");

  @DataSessionConfiguration(daos = {})
  TestDataSessionSupplier dataSessionSupplier;

  KeyValueMigrationStep_2_78 underTest = new KeyValueMigrationStep_2_78();

  @Test
  void testMigrate() throws Exception {
    try (Connection conn = dataSessionSupplier.openConnection(); Statement statement = conn.createStatement()) {
      String table = underTest.isPostgresql(conn) ? PG_TABLE : H2_TABLE;
      for (String format : FORMATS) {
        statement.execute(table.replace("${format}", format));
      }

      underTest.migrate(conn);

      if (underTest.isPostgresql(conn)) {
        try (PreparedStatement selectType = conn.prepareStatement(COLUMN_TYPE)) {
          selectType.setString(2, "value");
          for (String format : FORMATS) {
            selectType.setString(1, "%s_key_value".formatted(format));
            ResultSet results = selectType.executeQuery();
            assertTrue(results.next(), format);
            assertThat(format, results.getString("data_type"), is("text"));
          }
        }
      }
    }
  }

  @Test
  void testMigrate_noTables() throws Exception {
    try (Connection conn = dataSessionSupplier.openConnection()) {
      assertDoesNotThrow(() -> underTest.migrate(conn));
    }
  }

  private static final String H2_TABLE = """
      CREATE TABLE IF NOT EXISTS ${format}_key_value (
         key_value_id    INT GENERATED BY DEFAULT AS IDENTITY,
         repository_id   INT NOT NULL,
         category        VARCHAR NOT NULL,
         `key`           VARCHAR NOT NULL,
         `value`         CHARACTER LARGE OBJECT,
         created         TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

         CONSTRAINT pk_${format}_key_value_id PRIMARY KEY (key_value_id)
      );

      CREATE UNIQUE INDEX IF NOT EXISTS uk_${format}_repository_category_key
        ON ${format}_key_value (repository_id, category, `key`);

      CREATE INDEX IF NOT EXISTS idx_${format}_key_value_repository_key
        ON ${format}_key_value(repository_id, `key`);
            """;

  private static final String PG_TABLE = """
      CREATE TABLE IF NOT EXISTS ${format}_key_value (
        key_value_id    INT GENERATED BY DEFAULT AS IDENTITY,
        repository_id   INT NOT NULL,
        category        VARCHAR NOT NULL,
        key             VARCHAR NOT NULL,
        value           VARCHAR,
        created         TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

        CONSTRAINT pk_${format}_key_value_id PRIMARY KEY (key_value_id)
      );

      CREATE UNIQUE INDEX IF NOT EXISTS uk_${format}_repository_category_key
          ON ${format}_key_value (repository_id, category, key);

      CREATE INDEX IF NOT EXISTS idx_${format}_key_value_repository_key
          ON ${format}_key_value(repository_id, key);
            """;

  private static final String COLUMN_TYPE = """
      SELECT data_type
      FROM information_schema.columns
      WHERE table_schema = (SELECT current_schema)
        AND table_name = ?
        AND column_name = ?;
                """;
}
