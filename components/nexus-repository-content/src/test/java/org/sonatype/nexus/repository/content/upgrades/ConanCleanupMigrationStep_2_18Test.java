/*
 * Sonatype Nexus (TM) Open Source Version
 * Copyright (c) 2008-present Sonatype, Inc.
 * All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.
 *
 * This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
 * which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.
 *
 * Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
 * of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
 * Eclipse Foundation. All other trademarks are the property of their respective owners.
 */
package org.sonatype.nexus.repository.content.upgrades;

import java.sql.Connection;
import java.sql.SQLException;

import org.sonatype.goodies.testsupport.Test5Support;
import org.sonatype.nexus.testdb.DataSessionConfiguration;
import org.sonatype.nexus.testdb.DatabaseExtension;
import org.sonatype.nexus.testdb.DatabaseTest;
import org.sonatype.nexus.testdb.TestDataSessionSupplier;

import org.junit.jupiter.api.extension.ExtendWith;

import static java.util.Arrays.stream;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.sonatype.nexus.datastore.api.DataStoreManager.DEFAULT_DATASTORE_NAME;
import static org.sonatype.nexus.repository.content.upgrades.ConanCleanupMigrationStep_2_18.NEW_CONSTRAINT_NAME;
import static org.sonatype.nexus.repository.content.upgrades.ConanCleanupMigrationStep_2_18.OLD_CONSTRAINT_NAME;
import static org.sonatype.nexus.repository.content.upgrades.ConanCleanupMigrationStep_2_18.OLD_INDEX_NAME;
import static org.sonatype.nexus.repository.content.upgrades.ConanCleanupMigrationStep_2_18.OLD_REVISION_COLUMN_NAME;
import static org.sonatype.nexus.repository.content.upgrades.ConanCleanupMigrationStep_2_18.OLD_REVISION_TIME_COLUMN_NAME;
import static org.sonatype.nexus.repository.content.upgrades.ConanCleanupMigrationStep_2_18.TABLE_NAME;

@ExtendWith(DatabaseExtension.class)
class ConanCleanupMigrationStep_2_18Test
    extends Test5Support
{
  private static final String NEW_INDEX_NAME = "idx_conan_component_coordinates";

  private static final String OLD_SCHEMA =
      "CREATE TABLE IF NOT EXISTS conan_component ("
          + "component_id  INT GENERATED BY DEFAULT AS IDENTITY,"
          + "repository_id INT NOT NULL,"
          + "namespace     VARCHAR NOT NULL,"
          + "name          VARCHAR NOT NULL,"
          + "kind          VARCHAR NOT NULL,"
          + "version       VARCHAR NOT NULL,"
          + "normalized_version VARCHAR,"
          + "created       TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,"
          + "last_updated  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,"
          + "revision      VARCHAR NOT NULL DEFAULT '',"
          + "revision_time TIMESTAMP WITH TIME ZONE NULL,"
          + "CONSTRAINT pk_conan_component_id PRIMARY KEY (component_id)";

  private static final String OLD_SCHEMA_WITH_OLD_CONSTRAINT =
      String.format(OLD_SCHEMA
          + ", CONSTRAINT %s UNIQUE (repository_id, namespace, name, version, revision)"
          + ")", OLD_CONSTRAINT_NAME);

  private static final String OLD_SCHEMA_WITH_NEW_CONSTRAINT =
      String.format(OLD_SCHEMA
          + ", CONSTRAINT %s UNIQUE (repository_id, namespace, name, version)"
          + ")", NEW_CONSTRAINT_NAME);

  private static final String[] OLD_INDEX_LIST = new String[]{
      String.format("CREATE INDEX IF NOT EXISTS idx_conan_component_kind ON %s (kind)", TABLE_NAME),
      String.format("CREATE INDEX IF NOT EXISTS idx_conan_normalized_version ON %s (normalized_version)", TABLE_NAME),
      String.format(
          "CREATE INDEX IF NOT EXISTS idx_conan_component_coordinates ON %s (repository_id, namespace, name, version)",
          TABLE_NAME),
      String.format(
          "CREATE UNIQUE INDEX IF NOT EXISTS %s ON %s (repository_id, namespace, name, version, revision)",
          OLD_INDEX_NAME,
          TABLE_NAME)
  };

  @DataSessionConfiguration
  TestDataSessionSupplier sessionRule;

  private ConanCleanupMigrationStep_2_18 underTest = new ConanCleanupMigrationStep_2_18();

  @DatabaseTest
  public void testUpgrade() throws Exception {
    try (Connection conn = sessionRule.openConnection(DEFAULT_DATASTORE_NAME)) {
      // create old schema
      underTest.runStatement(conn, OLD_SCHEMA_WITH_OLD_CONSTRAINT);

      // create old indexes
      stream(OLD_INDEX_LIST).forEach(index -> {
        try {
          underTest.runStatement(conn, index);
        }
        catch (SQLException e) {
          throw new RuntimeException("Failed to create old index: " + index, e);
        }
      });

      assertTrue("table doesn't exist!", underTest.tableExists(conn, TABLE_NAME));
      assertTrue("old column doesn't exist!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_COLUMN_NAME));
      assertTrue("old column doesn't exist!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_TIME_COLUMN_NAME));
      assertTrue("old constraint doesn't exist!", underTest.constraintExists(conn, TABLE_NAME, OLD_CONSTRAINT_NAME));
      assertTrue("old index doesn't exist!", underTest.indexExists(conn, TABLE_NAME, OLD_INDEX_NAME));
      assertTrue("new index doesn't exist!", underTest.indexExists(conn, TABLE_NAME, NEW_INDEX_NAME));
      assertFalse("new constraint exists!", underTest.constraintExists(conn, TABLE_NAME, NEW_CONSTRAINT_NAME));

      underTest.migrate(conn);

      assertFalse("old index not removed!", underTest.indexExists(conn, OLD_INDEX_NAME));
      assertFalse("old constraint not removed!", underTest.constraintExists(conn, TABLE_NAME, OLD_CONSTRAINT_NAME));
      assertFalse("old column not removed!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_COLUMN_NAME));
      assertFalse("old column not removed!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_TIME_COLUMN_NAME));
      assertFalse("old index not removed!", underTest.indexExists(conn, TABLE_NAME, OLD_INDEX_NAME));
      assertTrue("new index doesn't exist!", underTest.indexExists(conn, TABLE_NAME, NEW_INDEX_NAME));
      assertTrue("new constraint not added!", underTest.constraintExists(conn, TABLE_NAME, NEW_CONSTRAINT_NAME));
    }
  }

  @DatabaseTest
  public void testUpgrade_tableNotExist() throws Exception {
    try (Connection conn = sessionRule.openConnection(DEFAULT_DATASTORE_NAME)) {
      underTest.migrate(conn);
      // The real check here is that the migration does not error.
      assertFalse("Sanity check - table exists", underTest.tableExists(conn, TABLE_NAME));
    }
  }

  @DatabaseTest
  public void testUpgrade_skipsAddConstraintWhenDropConstraintDoesNothing() throws Exception {
    try (Connection conn = sessionRule.openConnection(DEFAULT_DATASTORE_NAME)) {
      // create old schema
      underTest.runStatement(conn, OLD_SCHEMA_WITH_NEW_CONSTRAINT);

      // create old indexes
      stream(OLD_INDEX_LIST).forEach(index -> {
        try {
          underTest.runStatement(conn, index);
        }
        catch (SQLException e) {
          throw new RuntimeException("Failed to create old index: " + index, e);
        }
      });

      assertTrue("table doesn't exist!", underTest.tableExists(conn, TABLE_NAME));
      assertTrue("old column doesn't exist!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_TIME_COLUMN_NAME));
      assertTrue("old column doesn't exist!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_COLUMN_NAME));
      assertTrue("new constraint doesn't exist!", underTest.constraintExists(conn, TABLE_NAME, NEW_CONSTRAINT_NAME));
      assertTrue("old index doesn't exist!", underTest.indexExists(conn, TABLE_NAME, OLD_INDEX_NAME));
      assertTrue("new index doesn't exist!", underTest.indexExists(conn, TABLE_NAME, NEW_INDEX_NAME));

      underTest.migrate(conn);

      assertFalse("old index not removed!", underTest.indexExists(conn, OLD_INDEX_NAME));
      assertFalse("old constraint added again!", underTest.constraintExists(conn, TABLE_NAME, OLD_CONSTRAINT_NAME));
      assertFalse("old column not removed!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_COLUMN_NAME));
      assertFalse("old column not removed!", underTest.columnExists(conn, TABLE_NAME, OLD_REVISION_TIME_COLUMN_NAME));
      assertFalse("old index not removed!", underTest.indexExists(conn, TABLE_NAME, OLD_INDEX_NAME));
      assertTrue("new index doesn't exist!", underTest.indexExists(conn, TABLE_NAME, NEW_INDEX_NAME));
      assertTrue("new constraint removed!", underTest.constraintExists(conn, TABLE_NAME, NEW_CONSTRAINT_NAME));
    }
  }
}
