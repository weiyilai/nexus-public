<?xml version="1.0" encoding="UTF-8" ?>
<!--

    Sonatype Nexus (TM) Open Source Version
    Copyright (c) 2008-present Sonatype, Inc.
    All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.

    This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
    which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.

    Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
    of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
    Eclipse Foundation. All other trademarks are the property of their respective owners.

-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.sonatype.nexus.repository.search.sql.store.SearchTableDAO">
  <insert id="createSchema" databaseId="PostgreSQL">
    CREATE TABLE IF NOT EXISTS search_components
    (
      repository_id          INTEGER                  NOT NULL,
      component_id           INTEGER                  NOT NULL,
      format                 VARCHAR                  NOT NULL,
      namespace              VARCHAR                  NOT NULL,
      search_component_name  VARCHAR                  NOT NULL,
      component_kind         VARCHAR                  NOT NULL,
      version                VARCHAR                  NOT NULL,
      last_modified          TIMESTAMP WITH TIME ZONE,
      search_repository_name VARCHAR(200)             NOT NULL,
      normalised_version     VARCHAR                  NOT NULL,
      prerelease             BOOLEAN                  NOT NULL DEFAULT false,
      keywords                         TSVECTOR,
      md5                              TSVECTOR,
      sha1                             TSVECTOR,
      sha256                           TSVECTOR,
      sha512                           TSVECTOR,
      format_field_values_1            TSVECTOR,
      format_field_values_2            TSVECTOR,
      format_field_values_3            TSVECTOR,
      format_field_values_4            TSVECTOR,
      format_field_values_5            TSVECTOR,
      format_field_values_6            TSVECTOR,
      format_field_values_7            TSVECTOR,
      uploaders                        TSVECTOR,
      uploader_ips                     TSVECTOR,
      paths                            VARCHAR,
      tsvector_paths                   TSVECTOR,
      tsvector_format                  TSVECTOR       NOT NULL,
      tsvector_namespace               TSVECTOR       NOT NULL,
      tsvector_search_component_name   TSVECTOR       NOT NULL,
      tsvector_version                 TSVECTOR       NOT NULL,
      tsvector_search_repository_name  TSVECTOR       NOT NULL,
      tsvector_tags                    TSVECTOR,
      entity_version                   INT,
      attributes                       ${JSON_TYPE},
      tags                             ${JSON_TYPE},
      last_event_time                  TIMESTAMP      WITH TIME ZONE,
      CONSTRAINT pk_search_components PRIMARY KEY (repository_id, component_id, format)
      );

    <!-- Indexes for search_components handled by SearchTableIndexesMigrationStep_2_53 to avoid lock contention (NEXUS-49154) -->

    <!-- The following 6 columns are now in CREATE TABLE (lines 37-38, 48-51) -->
    <!-- SearchComponentsAdditionalColumnsMigrationStep handles adding them to existing databases -->
    <!-- Columns: format_field_values_6, format_field_values_7, tsvector_tags, entity_version, attributes, tags -->

    -- This is handled through an upgrade step as IF EXISTS cannot be used
    -- ALTER TABLE search_components RENAME COLUMN component_created TO last_modified;

    DROP INDEX IF EXISTS idx_search_components_paths;

    <!-- pg_trgm extension and GIST index handled by SearchTableIndexesMigrationStep_2_53 to avoid lock contention (NEXUS-49154) -->

    CREATE TABLE IF NOT EXISTS search_assets
    (
      format            VARCHAR NOT NULL,
      repository_id     INT NOT NULL,
      component_id      INT NOT NULL,
      asset_id          INT NOT NULL,
      path              VARCHAR NOT NULL,
      asset_format_value_1   VARCHAR,
      asset_format_value_2   VARCHAR,
      asset_format_value_3   VARCHAR,
      asset_format_value_4   VARCHAR,
      asset_format_value_5   VARCHAR,
      asset_format_value_6   VARCHAR,
      asset_format_value_7   VARCHAR,
      asset_format_value_8   VARCHAR,
      asset_format_value_9   VARCHAR,
      asset_format_value_10   VARCHAR,
      asset_format_value_11   VARCHAR,
      asset_format_value_12   VARCHAR,
      asset_format_value_13   VARCHAR,
      asset_format_value_14   VARCHAR,
      asset_format_value_15   VARCHAR,
      asset_format_value_16   VARCHAR,
      asset_format_value_17   VARCHAR,
      asset_format_value_18   VARCHAR,
      asset_format_value_19   VARCHAR,
      asset_format_value_20   VARCHAR,
      CONSTRAINT pk_search_assets PRIMARY KEY (format, repository_id, component_id, asset_id)
    );

    <!-- Indexes for search_assets handled by SearchTableIndexesMigrationStep_2_53 to avoid lock contention (NEXUS-49154) -->

  </insert>

  <insert id="createSchema" databaseId="H2">
    CREATE TABLE IF NOT EXISTS search_components
    (
    repository_id          INTEGER                  NOT NULL,
    component_id           INTEGER                  NOT NULL,
    format                 VARCHAR                  NOT NULL,
    namespace              VARCHAR                  NOT NULL,
    search_component_name  VARCHAR                  NOT NULL,
    component_kind         VARCHAR                  NOT NULL,
    version                VARCHAR                  NOT NULL,
    last_modified          TIMESTAMP WITH TIME ZONE,
    search_repository_name VARCHAR(200)             NOT NULL,
    normalised_version     VARCHAR                  NOT NULL,
    prerelease             BOOLEAN                  NOT NULL DEFAULT false,
    uploaders              VARCHAR,
    uploader_ips           VARCHAR,
    last_event_time        TIMESTAMP WITH TIME ZONE,
    entity_version         INT,
    attributes             JSON,
    tags                   JSON,
    paths                  VARCHAR,
    keywords               VARCHAR,
    md5                    VARCHAR,
    sha1                   VARCHAR,
    sha256                 VARCHAR,
    sha512                 VARCHAR,
    format_field_values_1  VARCHAR,
    format_field_values_2  VARCHAR,
    format_field_values_3  VARCHAR,
    format_field_values_4  VARCHAR,
    format_field_values_5  VARCHAR,
    format_field_values_6  VARCHAR,
    format_field_values_7  VARCHAR,
    CONSTRAINT pk_search_components PRIMARY KEY (repository_id, component_id, format)
    );

    <!-- Indexes for search_components (H2) handled by SearchTableIndexesMigrationStep_2_53 to avoid lock contention (NEXUS-49154) -->

    CREATE TABLE IF NOT EXISTS search_assets
    (
      format            VARCHAR NOT NULL,
      repository_id     INT NOT NULL,
      component_id      INT NOT NULL,
      asset_id          INT NOT NULL,
      path              VARCHAR NOT NULL,
      asset_format_value_1   VARCHAR,
      asset_format_value_2   VARCHAR,
      asset_format_value_3   VARCHAR,
      asset_format_value_4   VARCHAR,
      asset_format_value_5   VARCHAR,
      asset_format_value_6   VARCHAR,
      asset_format_value_7   VARCHAR,
      asset_format_value_8   VARCHAR,
      asset_format_value_9   VARCHAR,
      asset_format_value_10   VARCHAR,
      asset_format_value_11   VARCHAR,
      asset_format_value_12   VARCHAR,
      asset_format_value_13   VARCHAR,
      asset_format_value_14   VARCHAR,
      asset_format_value_15   VARCHAR,
      asset_format_value_16   VARCHAR,
      asset_format_value_17   VARCHAR,
      asset_format_value_18   VARCHAR,
      asset_format_value_19   VARCHAR,
      asset_format_value_20   VARCHAR,
      CONSTRAINT pk_search_assets PRIMARY KEY (format, repository_id, component_id, asset_id)
    );
  </insert>

  <sql id="repositoryMatch">
    repository_id = #{repositoryId}
    AND format = #{format}
  </sql>

  <sql id="componentMatch">
    <include refid="repositoryMatch"/>
    AND component_id = #{componentId}
  </sql>

  <sql id="PKMatch">
    <include refid="componentMatch"/>
  </sql>

  <resultMap id="searchTableData" type="org.sonatype.nexus.repository.search.sql.store.SearchRecordData">
    <id property="repositoryId" column="repository_id" />
    <id property="componentId" column="component_id" />
    <id property="format" column="format" />
    <result property="namespace" column="namespace"/>
    <result property="componentName" column="search_component_name"/>
    <result property="componentKind" column="component_kind"/>
    <result property="version" column="version"/>
    <result property="normalisedVersion" column="normalised_version"/>
    <result property="lastModified" column="last_modified"/>
    <result property="repositoryName" column="search_repository_name"/>
    <result property="prerelease" column="prerelease"/>
  </resultMap>

  <insert id="save" parameterType="SearchRecordData" databaseId="PostgreSQL">
    -- Only insert if the component still exists - we achieve this by using the FROM clause below to check the existence of the component
    -- In a multi node setup, as we can't use distributed cooperation for processing a if one node has deleted all the component records for a given repository in response to a
    -- ContentRepositoryDeleted event, for a  then we don't want a delayed update from another node to re-introduce
    -- any of those records.
      INSERT INTO search_components(repository_id, component_id, format, namespace, search_component_name, version,
          search_repository_name, tsvector_format, tsvector_namespace, tsvector_version, tsvector_search_repository_name, component_kind,
          normalised_version, prerelease, attributes, entity_version, paths, tsvector_search_component_name, uploaders, uploader_ips, tsvector_paths,
          keywords, md5, sha1, sha256, sha512, format_field_values_1, format_field_values_2,
          format_field_values_3, format_field_values_4, format_field_values_5, format_field_values_6, format_field_values_7, tsvector_tags, tags, last_modified)
        SELECT
           #{repositoryId}, #{componentId}, #{format}, #{namespace}, #{componentName}, #{version}, #{repositoryName},
            to_tsvector('simple', coalesce(#{format}, '')),
            COALESCE(<include refid="toTsVector"><property name="tokens" value="namespaceNames"/></include>, ''::tsvector),
            COALESCE(<include refid="toTsVector"><property name="tokens" value="versionNames"/></include>, ''::tsvector),
            to_tsvector('simple', CONCAT('/', coalesce(#{repositoryName}, ''))),
            #{componentKind}, #{normalisedVersion}, #{prerelease}, #{attributes}, COALESCE(#{entityVersion}, 1),
            <include refid="join"><property name="thePaths" value="paths"/></include>,
            <include refid="toTsVector"><property name="tokens" value="aliasComponentNames"/></include>,
            <include refid="toTsVector"><property name="tokens" value="uploaders"/></include>,
            <include refid="toTsVector"><property name="tokens" value="uploaderIps"/></include>,
            <include refid="toQuotedTsVector"><property name="tokens" value="paths"/></include>,
            <include refid="toTsVector"><property name="tokens" value="keywords"/></include>,
            <include refid="toTsVector"><property name="tokens" value="md5"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha1"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha256"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha512"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues1"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues2"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues3"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues4"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues5"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues6"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues7"/></include>,
            <include refid="toTsVector"><property name="tokens" value="tags"/></include>,
            #{tags, typeHandler=ListTypeHandler},
            #{lastModified}
        FROM ${format}_component comp
       WHERE component_id = #{componentId}
         AND <choose>
               <when test="entityVersion == null">comp.entity_version IS NULL</when>
               <otherwise>#{entityVersion} = comp.entity_version</otherwise>
             </choose>
        -- The WHERE clause above ensures the component still exists
        -- Thereby helping us avoid the need for DELET'ing threads to lock component ids
      ON CONFLICT ON CONSTRAINT pk_search_components
      DO
        UPDATE SET
          attributes = #{attributes},
          entity_version = COALESCE(#{entityVersion}, 1),
          component_kind = #{componentKind},
          prerelease = #{prerelease},
          last_modified = #{lastModified},
          uploaders = <include refid="toTsVector"><property name="tokens" value="uploaders"/></include>,
          uploader_ips = <include refid="toTsVector"><property name="tokens" value="uploaderIps"/></include>,
          paths = <include refid="join"><property name="thePaths" value="paths"/></include>,
          tsvector_paths = <include refid="toQuotedTsVector"><property name="tokens" value="paths"/></include>,
          keywords = <include refid="toTsVector"><property name="tokens" value="keywords"/></include>,
          md5 = <include refid="toTsVector"><property name="tokens" value="md5"/></include>,
          sha1 = <include refid="toTsVector"><property name="tokens" value="sha1"/></include>,
          sha256 = <include refid="toTsVector"><property name="tokens" value="sha256"/></include>,
          sha512 = <include refid="toTsVector"><property name="tokens" value="sha512"/></include>,
          format_field_values_1 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues1"/></include>,
          format_field_values_2 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues2"/></include>,
          format_field_values_3 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues3"/></include>,
          format_field_values_4 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues4"/></include>,
          format_field_values_5 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues5"/></include>,
          format_field_values_6 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues6"/></include>,
          format_field_values_7 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues7"/></include>,
          tsvector_tags = <include refid="toTsVector"><property name="tokens" value="tags"/></include>,
          tags = #{tags, typeHandler=ListTypeHandler}
        WHERE EXISTS(SELECT component_id
                       FROM ${format}_component
                      WHERE component_id = #{componentId}
                        AND <choose>
                              <when test="entityVersion == null">entity_version IS NULL</when>
                              <otherwise>#{entityVersion} = entity_version</otherwise>
                            </choose>)
        -- The EXISTS clause above ensures the component still exists
        -- Thereby helping us avoid the need for DELET'ing threads to lock component ids
  </insert>

  <insert id="save" parameterType="SearchRecordData" databaseId="H2">
    -- H2 version without TSVECTOR support - stores searchable data as VARCHAR
    -- Only insert if the component still exists
    -- Uses simpler MERGE KEY syntax for H2 compatibility
    MERGE INTO search_components (repository_id, component_id, format, namespace, search_component_name,
      component_kind, version, last_modified, search_repository_name, normalised_version, prerelease,
      uploaders, uploader_ips, entity_version, attributes, tags, paths, keywords, md5, sha1, sha256, sha512,
      format_field_values_1, format_field_values_2, format_field_values_3, format_field_values_4,
      format_field_values_5, format_field_values_6, format_field_values_7)
    KEY(repository_id, component_id, format)
    SELECT
      #{repositoryId},
      #{componentId},
      #{format},
      #{namespace},
      #{componentName},
      #{componentKind},
      #{version},
      #{lastModified},
      #{repositoryName},
      #{normalisedVersion},
      #{prerelease},
      <include refid="joinH2"><property name="thePaths" value="uploaders"/></include>,
      <include refid="joinH2"><property name="thePaths" value="uploaderIps"/></include>,
      COALESCE(#{entityVersion}, 1),
      #{attributes},
      #{tags, typeHandler=ListTypeHandler},
      <include refid="joinH2"><property name="thePaths" value="paths"/></include>,
      <include refid="joinH2"><property name="thePaths" value="keywords"/></include>,
      <include refid="joinH2"><property name="thePaths" value="md5"/></include>,
      <include refid="joinH2"><property name="thePaths" value="sha1"/></include>,
      <include refid="joinH2"><property name="thePaths" value="sha256"/></include>,
      <include refid="joinH2"><property name="thePaths" value="sha512"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues1"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues2"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues3"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues4"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues5"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues6"/></include>,
      <include refid="joinH2"><property name="thePaths" value="formatFieldValues7"/></include>
    FROM ${format}_component comp
    WHERE comp.component_id = #{componentId}
      AND <choose>
            <when test="entityVersion == null">comp.entity_version IS NULL</when>
            <otherwise>#{entityVersion} = comp.entity_version</otherwise>
          </choose>
  </insert>

  <delete id="delete">
    DELETE
    FROM search_components
    WHERE <include refid="PKMatch"/>
  </delete>

  <delete id="deleteSearchAssets">
    DELETE
    FROM search_assets
    WHERE repository_id = #{repositoryId}
    AND format = #{format}
    <foreach collection="componentIds" item="componentId" open="AND component_id IN (" separator="," close=")">
      ${componentId}
    </foreach>
  </delete>

  <delete id="deleteComponentIds">
    DELETE
    FROM search_components
    WHERE repository_id = #{repositoryId}
      AND format = #{format}
      <foreach collection="componentIds" item="componentId" open="AND component_id IN (" separator="," close=")">
        ${componentId}
      </foreach>
  </delete>

  <delete id="deleteAllForRepository" databaseId="PostgreSQL">
    WITH toBeDeleted as (
        SELECT component_id
        FROM search_components
        WHERE <include refid="repositoryMatch"/>
    <if test="limit gt 0"> LIMIT ${limit}</if>)
    DELETE
    FROM search_components cs
    WHERE <include refid="repositoryMatch"/>
        AND cs.component_id IN (SELECT td.component_id FROM toBeDeleted td)
  </delete>

  <delete id="deleteAllForRepository" databaseId="H2">
    DELETE FROM search_components
    WHERE <include refid="repositoryMatch"/>
    AND component_id IN (
        SELECT component_id
        FROM search_components
        WHERE <include refid="repositoryMatch"/>
        <if test="limit gt 0"> LIMIT ${limit}</if>
    )
  </delete>

  <delete id="deleteAllSearchAssets" databaseId="PostgreSQL">
    WITH toBeDeleted as (
    SELECT component_id
    FROM search_assets
    WHERE <include refid="repositoryMatch"/>
    <if test="limit gt 0"> LIMIT ${limit}</if>)
    DELETE
    FROM search_assets cs
    WHERE <include refid="repositoryMatch"/>
    AND cs.component_id IN (SELECT td.component_id FROM toBeDeleted td)
  </delete>

  <delete id="deleteAllSearchAssets" databaseId="H2">
    DELETE FROM search_assets
    WHERE <include refid="repositoryMatch"/>
    AND component_id IN (
        SELECT component_id
        FROM search_assets
        WHERE <include refid="repositoryMatch"/>
        <if test="limit gt 0"> LIMIT ${limit}</if>
    )
  </delete>

  <resultMap id="searchDataMap" type="org.sonatype.nexus.repository.search.sql.store.SearchResultData">
    <id property="componentId" column="component_id" />
    <id property="repositoryId" column="repository_id" />
    <result property="namespace" column="namespace"/>
    <result property="componentName" column="search_component_name"/>
    <result property="version" column="version"/>
    <result property="normalisedVersion" column="normalised_version"/>
    <result property="repositoryName" column="search_repository_name"/>
    <result property="format" column="format"/>
    <result property="lastModified" column="last_modified" />
    <result property="attributes" column="attributes" />
    <result property="tags" column="tags" typeHandler="ListTypeHandler" />
  </resultMap>

  <select id="searchComponents" resultMap="searchDataMap" parameterType="SqlSearchRequest">
    -- The prefixes 'cs' and 'ap' are used to prevent ambiguity in column names.
    -- Be cautious when modifying them, as some classes rely on these prefixes for building filters.
    SELECT
        cs.component_id,
        cs.namespace,
        cs.search_component_name,
        cs.version,
        cs.normalised_version,
        cs.search_repository_name,
        cs.format,
        cs.last_modified,
        attributes,
        tags
    FROM search_components cs
    <if test="assetFilter != null">
      INNER JOIN (
      SELECT
        ap.format,
        ap.repository_id,
        ap.component_id
      FROM search_assets ap
      <where>
        (${assetFilter})
      </where>
      GROUP BY ap.format, ap.repository_id, ap.component_id
      ) content ON cs.format = content.format AND cs.repository_id = content.repository_id AND cs.component_id = content.component_id
    </if>
    <where>
      <if test="filter != null">(${filter})</if>
    </where>
    ORDER BY <if test="sortColumnName != null">
      ${sortColumnName} ${sortDirection}
      <if test="sortColumnName != defaultSortColumnName">, ${defaultSortColumnName}</if>
      <if test="sortColumnName != secondDefaultSortColumnName">, ${secondDefaultSortColumnName}</if>
    </if>
    <if test="sortColumnName == null">
      ${defaultSortColumnName} <if test="sortDirection != null">${sortDirection}</if>,
      ${secondDefaultSortColumnName} <if test="sortDirection != null">${sortDirection}</if>
    </if>
    <if test="limit != null">LIMIT #{limit}</if>
    OFFSET #{offset};
  </select>

  <select id="count" resultType="long" parameterType="SqlSearchRequest">
    -- The prefixes 'cs' and 'ap' are used to prevent ambiguity in column names.
    -- Be cautious when modifying them, as some classes rely on these prefixes for building filters.
    SELECT COUNT(cs.component_id)
    FROM search_components cs
    <if test="assetFilter != null">
      INNER JOIN (
      SELECT
      ap.format,
      ap.repository_id,
      ap.component_id
      FROM search_assets ap
      <where>
        (${assetFilter})
      </where>
      GROUP BY ap.format, ap.repository_id, ap.component_id
      ) content ON cs.format = content.format AND cs.repository_id = content.repository_id AND cs.component_id = content.component_id
    </if>
    <where>
      <if test="filter != null">(${filter})</if>
    </where>
  </select>

  <insert id="saveAsset" parameterType="SearchAssetRecord"  databaseId="PostgreSQL">
    INSERT INTO search_assets(format, repository_id, component_id, asset_id, path,
    asset_format_value_1,asset_format_value_2,asset_format_value_3,asset_format_value_4,asset_format_value_5, asset_format_value_6,
    asset_format_value_7,asset_format_value_8,asset_format_value_9,asset_format_value_10,asset_format_value_11, asset_format_value_12,
    asset_format_value_13,asset_format_value_14,asset_format_value_15,asset_format_value_16,asset_format_value_17, asset_format_value_18, asset_format_value_19, asset_format_value_20)
      SELECT
        #{searchAssetRecord.format}, #{searchAssetRecord.repositoryId}, #{searchAssetRecord.componentId}, #{searchAssetRecord.assetId}, #{searchAssetRecord.path},
        #{searchAssetRecord.assetFormatValue1},
        #{searchAssetRecord.assetFormatValue2},
        #{searchAssetRecord.assetFormatValue3},
        #{searchAssetRecord.assetFormatValue4},
        #{searchAssetRecord.assetFormatValue5},
        #{searchAssetRecord.assetFormatValue6},
        #{searchAssetRecord.assetFormatValue7},
        #{searchAssetRecord.assetFormatValue8},
        #{searchAssetRecord.assetFormatValue9},
        #{searchAssetRecord.assetFormatValue10},
        #{searchAssetRecord.assetFormatValue11},
        #{searchAssetRecord.assetFormatValue12},
        #{searchAssetRecord.assetFormatValue13},
        #{searchAssetRecord.assetFormatValue14},
        #{searchAssetRecord.assetFormatValue15},
        #{searchAssetRecord.assetFormatValue16},
        #{searchAssetRecord.assetFormatValue17},
        #{searchAssetRecord.assetFormatValue18},
        #{searchAssetRecord.assetFormatValue19},
        #{searchAssetRecord.assetFormatValue20}
      FROM ${searchAssetRecord.format}_asset a WHERE a.asset_id = #{searchAssetRecord.assetId}
    ON CONFLICT ON CONSTRAINT pk_search_assets DO NOTHING
  </insert>

  <insert id="saveAsset" parameterType="SearchAssetRecord"  databaseId="H2">
    MERGE INTO search_assets
    USING (
      SELECT
        #{searchAssetRecord.format} AS src_format,
        #{searchAssetRecord.repositoryId} AS repository_id,
        #{searchAssetRecord.componentId} AS component_id,
        #{searchAssetRecord.assetId} AS asset_id,
        #{searchAssetRecord.path} AS path,
        #{searchAssetRecord.assetFormatValue1} AS asset_format_value_1,
        #{searchAssetRecord.assetFormatValue2} AS asset_format_value_2,
        #{searchAssetRecord.assetFormatValue3} AS asset_format_value_3,
        #{searchAssetRecord.assetFormatValue4} AS asset_format_value_4,
        #{searchAssetRecord.assetFormatValue5} AS asset_format_value_5,
        #{searchAssetRecord.assetFormatValue6} AS asset_format_value_6,
        #{searchAssetRecord.assetFormatValue7} AS asset_format_value_7,
        #{searchAssetRecord.assetFormatValue8} AS asset_format_value_8,
        #{searchAssetRecord.assetFormatValue9} AS asset_format_value_9,
        #{searchAssetRecord.assetFormatValue10} AS asset_format_value_10,
        #{searchAssetRecord.assetFormatValue11} AS asset_format_value_11,
        #{searchAssetRecord.assetFormatValue12} AS asset_format_value_12,
        #{searchAssetRecord.assetFormatValue13} AS asset_format_value_13,
        #{searchAssetRecord.assetFormatValue14} AS asset_format_value_14,
        #{searchAssetRecord.assetFormatValue15} AS asset_format_value_15,
        #{searchAssetRecord.assetFormatValue16} AS asset_format_value_16,
        #{searchAssetRecord.assetFormatValue17} AS asset_format_value_17,
        #{searchAssetRecord.assetFormatValue18} AS asset_format_value_18,
        #{searchAssetRecord.assetFormatValue19} AS asset_format_value_19,
        #{searchAssetRecord.assetFormatValue20} AS asset_format_value_20
      FROM ${searchAssetRecord.format}_asset a
      WHERE a.asset_id = #{searchAssetRecord.assetId}
    ) src
    ON (search_assets."format" = src.src_format
        AND search_assets.repository_id = src.repository_id
        AND search_assets.component_id = src.component_id
        AND search_assets.asset_id = src.asset_id)
    WHEN NOT MATCHED THEN
      INSERT ("format", repository_id, component_id, asset_id, path,
              asset_format_value_1, asset_format_value_2, asset_format_value_3, asset_format_value_4, asset_format_value_5,
              asset_format_value_6, asset_format_value_7, asset_format_value_8, asset_format_value_9, asset_format_value_10,
              asset_format_value_11, asset_format_value_12, asset_format_value_13, asset_format_value_14, asset_format_value_15,
              asset_format_value_16, asset_format_value_17, asset_format_value_18, asset_format_value_19, asset_format_value_20)
      VALUES (src.src_format, src.repository_id, src.component_id, src.asset_id, src.path,
              src.asset_format_value_1, src.asset_format_value_2, src.asset_format_value_3, src.asset_format_value_4, src.asset_format_value_5,
              src.asset_format_value_6, src.asset_format_value_7, src.asset_format_value_8, src.asset_format_value_9, src.asset_format_value_10,
              src.asset_format_value_11, src.asset_format_value_12, src.asset_format_value_13, src.asset_format_value_14, src.asset_format_value_15,
              src.asset_format_value_16, src.asset_format_value_17, src.asset_format_value_18, src.asset_format_value_19, src.asset_format_value_20)
  </insert>

  <insert id="saveAssets" parameterType="java.util.Collection" databaseId="PostgreSQL">
    INSERT INTO search_assets(format, repository_id, component_id, asset_id, path,
                              asset_format_value_1,asset_format_value_2,asset_format_value_3,asset_format_value_4,asset_format_value_5, asset_format_value_6,
                              asset_format_value_7,asset_format_value_8,asset_format_value_9,asset_format_value_10,asset_format_value_11, asset_format_value_12,
                              asset_format_value_13,asset_format_value_14,asset_format_value_15,asset_format_value_16,asset_format_value_17, asset_format_value_18, asset_format_value_19, asset_format_value_20)
    VALUES
    <foreach collection="searchAssetRecords" separator="," item="searchAssetRecord">
      ( #{searchAssetRecord.format}, #{searchAssetRecord.repositoryId}, #{searchAssetRecord.componentId}, #{searchAssetRecord.assetId}, #{searchAssetRecord.path},
       #{searchAssetRecord.assetFormatValue1},
       #{searchAssetRecord.assetFormatValue2},
       #{searchAssetRecord.assetFormatValue3},
       #{searchAssetRecord.assetFormatValue4},
       #{searchAssetRecord.assetFormatValue5},
       #{searchAssetRecord.assetFormatValue6},
       #{searchAssetRecord.assetFormatValue7},
       #{searchAssetRecord.assetFormatValue8},
       #{searchAssetRecord.assetFormatValue9},
       #{searchAssetRecord.assetFormatValue10},
       #{searchAssetRecord.assetFormatValue11},
       #{searchAssetRecord.assetFormatValue12},
       #{searchAssetRecord.assetFormatValue13},
       #{searchAssetRecord.assetFormatValue14},
       #{searchAssetRecord.assetFormatValue15},
       #{searchAssetRecord.assetFormatValue16},
       #{searchAssetRecord.assetFormatValue17},
       #{searchAssetRecord.assetFormatValue18},
       #{searchAssetRecord.assetFormatValue19},
       #{searchAssetRecord.assetFormatValue20}
      )
    </foreach>
    ON CONFLICT ON CONSTRAINT pk_search_assets DO NOTHING
  </insert>

  <insert id="saveAssets" parameterType="java.util.Collection" databaseId="H2">
    MERGE INTO search_assets("format", repository_id, component_id, asset_id, path,
                              asset_format_value_1,asset_format_value_2,asset_format_value_3,asset_format_value_4,asset_format_value_5, asset_format_value_6,
                              asset_format_value_7,asset_format_value_8,asset_format_value_9,asset_format_value_10,asset_format_value_11, asset_format_value_12,
                              asset_format_value_13,asset_format_value_14,asset_format_value_15,asset_format_value_16,asset_format_value_17, asset_format_value_18, asset_format_value_19, asset_format_value_20)
    VALUES
    <foreach collection="searchAssetRecords" separator="," item="searchAssetRecord">
      ( #{searchAssetRecord.format}, #{searchAssetRecord.repositoryId}, #{searchAssetRecord.componentId}, #{searchAssetRecord.assetId}, #{searchAssetRecord.path},
       #{searchAssetRecord.assetFormatValue1},
       #{searchAssetRecord.assetFormatValue2},
       #{searchAssetRecord.assetFormatValue3},
       #{searchAssetRecord.assetFormatValue4},
       #{searchAssetRecord.assetFormatValue5},
       #{searchAssetRecord.assetFormatValue6},
       #{searchAssetRecord.assetFormatValue7},
       #{searchAssetRecord.assetFormatValue8},
       #{searchAssetRecord.assetFormatValue9},
       #{searchAssetRecord.assetFormatValue10},
       #{searchAssetRecord.assetFormatValue11},
       #{searchAssetRecord.assetFormatValue12},
       #{searchAssetRecord.assetFormatValue13},
       #{searchAssetRecord.assetFormatValue14},
       #{searchAssetRecord.assetFormatValue15},
       #{searchAssetRecord.assetFormatValue16},
       #{searchAssetRecord.assetFormatValue17},
       #{searchAssetRecord.assetFormatValue18},
       #{searchAssetRecord.assetFormatValue19},
       #{searchAssetRecord.assetFormatValue20}
      )
    </foreach>
  </insert>

  <insert id="saveBatch" parameterType="java.util.List" databaseId="PostgreSQL">
    INSERT INTO search_components(repository_id, component_id, format, namespace, search_component_name, version,
      search_repository_name, tsvector_format, tsvector_namespace, tsvector_version, tsvector_search_repository_name,
      component_kind, normalised_version, last_modified, prerelease, attributes, entity_version, paths, uploaders,
      uploader_ips, tsvector_search_component_name, tsvector_paths, keywords, md5, sha1, sha256, sha512,
      format_field_values_1, format_field_values_2, format_field_values_3, format_field_values_4, format_field_values_5, format_field_values_6,
      format_field_values_7, tsvector_tags, tags)
    VALUES
    <foreach collection="searchData" separator="," item="item">
      (#{item.repositoryId}, #{item.componentId},  #{item.format}, #{item.namespace},
       #{item.componentName},#{item.version}, #{item.repositoryName},
       to_tsvector('simple', COALESCE(#{item.format}, '')),
      COALESCE(<include refid="toTsVector"><property name="tokens" value="item.namespaceNames"/></include>, ''::tsvector),
      COALESCE(<include refid="toTsVector"><property name="tokens" value="item.versionNames"/></include>, ''::tsvector),
       to_tsvector('simple', CONCAT('/', coalesce(#{item.repositoryName}, ''))), #{item.componentKind}, #{item.normalisedVersion},
       #{item.lastModified}, #{item.prerelease}, #{item.attributes}, COALESCE(#{item.entityVersion}, 1),
      <include refid="join"><property name="thePaths" value="item.paths"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.uploaders"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.uploaderIps"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.aliasComponentNames"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.paths"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.keywords"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.md5"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha1"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha256"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha512"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues1"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues2"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues3"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues4"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues5"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues6"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues7"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.tags"/></include>,
      #{item.tags, typeHandler=ListTypeHandler})
    </foreach>
    ON CONFLICT ON CONSTRAINT pk_search_components
    DO
      UPDATE SET
        attributes = "excluded".attributes,
        entity_version = "excluded".entity_version,
        component_kind = "excluded".component_kind,
        prerelease = "excluded".prerelease,
        uploaders = "excluded".uploaders,
        uploader_ips = "excluded".uploader_ips,
        paths = "excluded".paths,
        tsvector_paths = "excluded".tsvector_paths,
        keywords = "excluded".keywords,
        md5 = "excluded".md5,
        sha1 = "excluded".sha1,
        sha256 = "excluded".sha256,
        sha512 = "excluded".sha512,
        format_field_values_1 = "excluded".format_field_values_1,
        format_field_values_2 = "excluded".format_field_values_2,
        format_field_values_3 = "excluded".format_field_values_3,
        format_field_values_4 = "excluded".format_field_values_4,
        format_field_values_5 = "excluded".format_field_values_5,
        format_field_values_6 = "excluded".format_field_values_6,
        format_field_values_7 = "excluded".format_field_values_7,
        tsvector_tags = "excluded".tsvector_tags,
        tags = "excluded".tags
  </insert>

  <insert id="saveBatch" parameterType="java.util.List" databaseId="H2">
     MERGE INTO search_components (repository_id, component_id, format, namespace, search_component_name,
           component_kind, version, last_modified, search_repository_name, normalised_version, prerelease,
           uploaders, uploader_ips, entity_version, attributes, tags, paths, keywords, md5, sha1, sha256, sha512,
           format_field_values_1, format_field_values_2, format_field_values_3, format_field_values_4,
           format_field_values_5, format_field_values_6, format_field_values_7)
    VALUES
         <foreach collection="searchData" separator="," item="item">
           (#{item.repositoryId},
            #{item.componentId},
            #{item.format},
            #{item.namespace},
            #{item.componentName},
            #{item.componentKind},
            #{item.version},
            #{item.lastModified},
            #{item.repositoryName},
            #{item.normalisedVersion},
            #{item.prerelease},
            <include refid="joinH2"><property name="thePaths" value="item.uploaders"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.uploaderIps"/></include>,
            COALESCE(#{item.entityVersion}, 1),
            #{item.attributes},
            #{item.tags, typeHandler=ListTypeHandler},
            <include refid="joinH2"><property name="thePaths" value="item.paths"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.keywords"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.md5"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.sha1"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.sha256"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.sha512"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues1"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues2"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues3"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues4"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues5"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues6"/></include>,
            <include refid="joinH2"><property name="thePaths" value="item.formatFieldValues7"/></include>)
         </foreach>
  </insert>

  <sql id="toTsVector" databaseId="PostgreSQL">
    <choose>
      <when test="${tokens}.isEmpty()">null</when>
      <otherwise>
        <foreach collection="${tokens}" separator="||" item="token" open="(" close=")">
          LOWER(#{token})::tsvector
        </foreach>
      </otherwise>
    </choose>
  </sql>

  <sql id="toQuotedTsVector" databaseId="PostgreSQL">
    <choose>
      <when test="${tokens}.isEmpty()">null</when>
      <otherwise>
        <foreach collection="${tokens}" separator="||" item="token" open="(" close=")">
          #{token, typeHandler=QuotingTypeHandler}::tsvector
        </foreach>
      </otherwise>
    </choose>
  </sql>

  <sql id="join" databaseId="PostgreSQL">
    <choose>
      <when test="${thePaths}.isEmpty()">null</when>
      <otherwise>
        (SELECT STRING_AGG('{' || path || '}', ' ')
        FROM unnest(ARRAY[<foreach collection="${thePaths}" separator="," item="path">#{path}::VARCHAR</foreach>]) AS path)
      </otherwise>
    </choose>
  </sql>

  <sql id="joinH2" databaseId="H2">
    <choose>
      <when test="${thePaths}.isEmpty()">null</when>
      <otherwise>
        <foreach collection="${thePaths}" separator=" || ' ' || " item="path" open="(" close=")">
          COALESCE(#{path}, '')
        </foreach>
      </otherwise>
    </choose>
  </sql>

  <select id="hasRepositoryEntries" resultType="boolean">
    SELECT EXISTS(SELECT 1 FROM search_components WHERE search_repository_name = #{repositoryName} LIMIT 1)
  </select>
</mapper>

